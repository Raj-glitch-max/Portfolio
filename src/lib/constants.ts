import type { ScriptItem, Project, PersonalInfo, Education, SocialLink } from './types';

export const ANIMATION_DURATION = {
    GLITCH_INTERVAL_MIN: 3000,
    GLITCH_INTERVAL_MAX: 8000,
    GLITCH_DURATION: 300,
};

export const COLORS = {
    CYAN: '#00d9ff',
    GREEN: '#00ff41',
    RED: '#ff4444',
    MAGENTA: '#ff00ff',
    YELLOW: '#ffbe0b',
    WHITE: '#ffffff',
    BLACK: '#000000',
};

export const DEVOPS_COMMANDS = [
    'kubectl apply -f deployment.yaml',
    'docker build -t app:latest .',
    'terraform init',
    'terraform plan',
    'terraform apply -auto-approve',
    'git commit -m "feat: initial commit"',
    'git push origin main',
    'npm run build',
    'aws s3 cp . s3://bucket',
    'helm install my-app ./chart',
    'ansible-playbook site.yml',
    'systemctl status docker',
    'journalctl -u kubelet -f',
    'netstat -tulpn',
    'ps aux | grep node',
    'top',
    'htop',
    'chmod +x script.sh',
    './deploy.sh',
    'ssh user@server',
    'scp file user@server:/tmp',
    'curl -I https://example.com',
    'ping 8.8.8.8',
    'traceroute google.com',
    'dig google.com',
    'nslookup google.com',
    'whoami',
    'uptime',
    'df -h',
    'free -m',
];

export const SCRIPT_ITEMS: ScriptItem[] = [
    { id: 'about', name: 'about.sh', icon: 'FileText', animationType: 'git' },
    { id: 'skills', name: 'skills.sh', icon: 'Target', animationType: 'k8s' },
    { id: 'projects', name: 'projects.sh', icon: 'Rocket', animationType: 'docker' },
    { id: 'blog', name: 'blog.sh', icon: 'FileEdit', animationType: 'logs' },
    { id: 'contact', name: 'contact.sh', icon: 'Mail', animationType: 'network' },
];

export const PERSONAL_INFO: PersonalInfo = {
    name: 'Raj Patil',
    title: 'DevOps Engineer',
    email: 'rpdinkar92260@gmail.com',
    location: 'Pune, India',
    bio: 'DevOps engineer passionate about building scalable infrastructure and automating complex deployments. I focus on containerization, orchestration, and CI/CD pipelines to help teams ship faster and operate reliably. Currently exploring advanced Kubernetes patterns and cloud cost optimization while contributing to open-source infrastructure projects.',
    whyDevOps: "I chose DevOps because I'm fascinated by the intersection of development and infrastructureâ€”where automation meets reliability at scale. There's a real satisfaction in designing systems that enable teams to deploy confidently, reduce operational friction, and focus on building features instead of fighting infrastructure issues. I'm driven by solving real problems through elegant automation and building the infrastructure that powers modern applications.",
    learningGoals: 'Advanced Kubernetes, Cloud Cost Optimization',
    status: 'Open to Work',
};

export const EDUCATION: Education[] = [
    {
        institution: 'MIT ADT University',
        degree: 'B.Tech in Electronics and Computer Engineering',
        duration: '2022 - 2026',
    },
];

export const SOCIAL_LINKS: SocialLink[] = [
    { platform: 'GitHub', url: 'https://github.com/Raj-glitch-max' },
    { platform: 'LinkedIn', url: 'https://www.linkedin.com/in/raj-patil-311b6b259/' },
    { platform: 'Twitter', url: 'https://x.com/RAJPATIL901' },
];

export const PROJECTS: Project[] = [
    {
        name: 'CodeArena',
        shortDescription: 'Real-time competitive coding platform with microservices architecture and ELO-based ranking.',
        fullDescription: 'CodeArena is a production-grade competitive programming platform where developers battle in real-time 1v1 or group matches. Players solve algorithmic challenges under time pressure while their code executes in sandboxed environments. The system features a microservices architecture with 5 backend services (Auth, Battle, Execution, Rating, WebSocket) deployed on Kubernetes. Built with zero-trust networking, aggressive horizontal pod autoscaling for execution workers, and full observability using Prometheus, Grafana, and Jaeger. The platform handles 100+ concurrent battles with sub-second WebSocket synchronization and maintains an ELO-based leaderboard system.',
        techStack: ['React', 'Vite', 'TypeScript', 'Node.js', 'Express', 'PostgreSQL', 'Redis', 'RabbitMQ', 'Socket.IO', 'Docker', 'Kubernetes', 'Terraform', 'Prometheus', 'Grafana', 'Jaeger', 'Jenkins'],
        features: [
            'Real-time 1v1 and group battles with WebSocket synchronization',
            'Microservices architecture: Auth, Battle, Execution, Rating, WebSocket services',
            'Sandboxed code execution with RabbitMQ queue processing (10s timeout, 256MB limit)',
            'ELO-based ranking system with live leaderboards',
            'Zero-trust networking with Kubernetes NetworkPolicies',
            'Aggressive HPA scaling: 5-30 replicas for execution workers during peak load',
            'Full observability: Prometheus metrics, Grafana dashboards, Jaeger tracing',
            'Production deployment on AWS EKS with RDS Multi-AZ and ElastiCache',
        ],
        achievements: [
            'Built production-grade microservices with service mesh communication patterns',
            'Implemented aggressive autoscaling handling 500-1000 execution jobs during peak hours',
            'Deployed on AWS EKS with zero-downtime rolling updates via Jenkins CI/CD',
            'Achieved sub-100ms WebSocket latency with Redis pub/sub across replicas',
        ],
        learningOutcomes: [
            'Microservices communication patterns (REST, pub/sub, message queues)',
            'Kubernetes production deployment and HPA scaling strategies',
            'Real-time systems with Socket.IO and Redis pub/sub',
            'Zero-trust networking and RBAC in Kubernetes',
        ],
        useCases: ['Competitive Programming Platforms', 'Real-time Gaming Infrastructure', 'Code Execution SaaS'],
        githubUrl: 'https://github.com/Raj-glitch-max/CodeArena',
        architecture: 'graph TB\n    Client[React SPA] --> Ingress[Nginx Ingress]\n    Ingress -->|/api/auth| Auth[Auth Service]\n    Ingress -->|/api/battle| Battle[Battle Service]\n    Ingress -->|/api/execution| Exec[Execution Service]\n    Ingress -->|/api/rating| Rating[Rating Service]\n    Ingress -->|ws://| WS[WebSocket Service]\n    Auth --> PG[(PostgreSQL)]\n    Auth --> Redis[(Redis)]\n    Battle --> PG\n    Battle --> Redis\n    Exec --> RMQ[RabbitMQ]\n    Rating --> PG\n    WS --> Redis',
    },
    {
        name: 'Terraform Multi-Cloud Infrastructure',
        shortDescription: 'Production-grade Infrastructure-as-Code (IaC) for AWS, Azure, and GCP with automated Jenkins CI/CD.',
        fullDescription: 'A comprehensive DevOps engineering project that automates the provisioning of enterprise-grade cloud infrastructure across three major providers: AWS (40%), Azure (30%), and GCP (30%). It utilizes modular Terraform code to deploy Kubernetes clusters (EKS, AKS, GKE), managed databases (RDS, Cloud SQL), and secure networking architectures. The project features a robust Jenkins CI/CD pipeline running in Docker that enforces DevSecOps best practices, including automated code validation, security scanning with tfsec and Checkov, cost estimation with Infracost, and manual approval gates for production deployments.',
        techStack: ['Terraform', 'Jenkins', 'Docker', 'AWS', 'Azure', 'GCP', 'Kubernetes', 'Bash', 'Git'],
        features: [
            'Multi-Cloud Architecture: Unified provisioning for AWS, Azure, and GCP',
            'Modular Design: Reusable Terraform modules for VPC, EKS, RDS, GKE, and AKS',
            'Automated CI/CD: Jenkins pipeline for validate, plan, and apply stages',
            'DevSecOps Integration: Automated security scanning using tfsec and Checkov',
            'Cost Estimation: Pre-deployment cost analysis using Infracost',
            'State Management: Remote state locking with S3 and DynamoDB',
        ],
        achievements: [
            'Modernized legacy infrastructure by migrating from Oracle Cloud to an AWS-focused multi-cloud strategy',
            'Upgraded Terraform codebase from version 0.15 to 1.5+ to leverage modern features',
            'Implemented a zero-cost local CI/CD solution using Jenkins and Docker',
            'Mastered the management of complex dependencies between cross-cloud resources',
        ],
        learningOutcomes: [
            'Advanced Terraform state management',
            'Multi-cloud networking patterns',
            'Jenkins pipeline orchestration',
        ],
        useCases: ['Enterprise Infrastructure Provisioning', 'Disaster Recovery Strategy'],
        githubUrl: 'https://github.com/Raj-glitch-max/Terraform-MultiCloud-Infrastructure',
        architecture: 'graph TD\n    Dev[Developer] -->|Push Code| GitHub\n    GitHub -->|Webhook| Jenkins[Jenkins Docker]\n    Jenkins -->|Pull & Scan| Security[tfsec/Checkov]\n    Security -->|Plan| Terraform\n    Terraform -->|Apply| AWS[AWS EKS/RDS]\n    Terraform -->|Apply| Azure[Azure AKS]\n    Terraform -->|Apply| GCP[GCP GKE]',
    },
    {
        name: 'HostMaster',
        shortDescription: 'AWS Cost Optimization & Infrastructure Monitoring SaaS.',
        fullDescription: 'A comprehensive SaaS platform that connects to users\' AWS accounts to scan for idle resources, security vulnerabilities, and cost anomalies. It provides actionable recommendations to reduce cloud bills and improve security posture using automated background scanning. The system uses a microservices approach with a dedicated worker fleet for processing heavy scanning jobs without blocking the main API.',
        techStack: ['Node.js', 'Express', 'PostgreSQL', 'Redis', 'Bull', 'React', 'Next.js', 'Docker', 'Terraform'],
        features: [
            'Automated AWS Resource Scanning (EC2, RDS)',
            'Cost Anomaly Detection & Forecasting',
            'Background Job Processing with Bull/Redis',
            'AES-256 Credential Encryption',
            'Role-Based Access Control (RBAC)',
            'Real-time scanning status updates',
        ],
        achievements: [
            'Built a scalable background job processing system',
            'Implemented secure AWS credential handling',
            'Optimized PostgreSQL queries for large datasets',
        ],
        learningOutcomes: [
            'Queue-based architecture patterns',
            'AWS SDK deep dive',
            'SaaS security best practices',
        ],
        useCases: ['Cloud Cost Reduction', 'Security Compliance Monitoring'],
        githubUrl: 'https://github.com/Raj-glitch-max/HostMaster',
        architecture: 'graph TD\n    User --> Frontend[Next.js UI]\n    Frontend --> API[Express API]\n    API --> DB[(PostgreSQL)]\n    API --> Redis[(Redis Queue)]\n    Redis --> Worker[Bull Worker]\n    Worker --> AWS[AWS SDK]\n    AWS --> Cloud[External AWS Account]',
    },
    {
        name: 'AI-Driven CI/CD Pipeline',
        shortDescription: 'An intelligent DevOps platform that uses AI to analyze build failures, optimize Docker images, and predict deployment risks.',
        fullDescription: 'This project revolutionizes the standard CI/CD workflow by integrating a Generative AI agent into the pipeline. Unlike traditional pipelines that simply fail on error, the AI-Driven CI/CD Pipeline analyzes build logs and code changes to provide actionable fix suggestions, optimizes Dockerfile configurations for smaller image sizes, and performs automated security audits. The system features a modern React dashboard for real-time visualization of build health and AI insights, utilizing Jenkins for orchestration and Kubernetes for scalable production deployments.',
        techStack: ['Jenkins', 'Docker', 'Kubernetes', 'Python', 'FastAPI', 'OpenAI/Gemini API', 'React', 'Terraform', 'ArgoCD', 'PostgreSQL'],
        features: [
            'AI Log Analysis: Automatically diagnoses build failures and suggests code fixes',
            'Smart Caching: AI-predicted dependency caching to speed up builds',
            'GitOps Deployment: Automated synchronization using ArgoCD',
            'Security Guardrails: Automated vulnerability scanning (SAST) in the pipeline',
            'Interactive Dashboard: Real-time visualization of pipeline metrics and AI recommendations',
        ],
        achievements: [
            'Successfully integrated Large Language Models (LLMs) into a DevOps workflow',
            'Mastered GitOps principles with ArgoCD and Kubernetes',
            'Built a full-stack dashboard to visualize complex CI/CD data',
        ],
        learningOutcomes: [
            'LLM integration in engineering workflows',
            'Advanced Kubernetes operators',
            'Full-stack observability',
        ],
        useCases: ['Automated Debugging', 'Pipeline Optimization'],
        githubUrl: 'https://github.com/Raj-glitch-max/AI-DRIVEN-self-healing-CICD.git',
        architecture: 'graph TD\n    Dev[Developer] -->|Commit| GitHub\n    GitHub -->|Trigger| Jenkins[Jenkins Server]\n    Jenkins -->|Build| Docker[Docker Agent]\n    Jenkins -->|Analyze| AI[AI Analysis API]\n    AI -->|Store| DB[(PostgreSQL)]\n    Jenkins -->|Deploy| ArgoCD\n    ArgoCD -->|Sync| K8s[Kubernetes Cluster]\n    K8s -->|Metrics| Prom[Prometheus]\n    DB -->|Data| Dashboard[React Dashboard]',
    },
    {
        name: 'FullStack-MicroServices',
        shortDescription: 'Production-grade EKS platform with GitOps & Progressive Delivery.',
        fullDescription: 'A portfolio-style, production-shaped platform demonstrating end-to-end microservices delivery on Kubernetes. It features EKS-ready hardened manifests, Terraform IaC for infrastructure, and ArgoCD for GitOps. The platform implements progressive delivery with Argo Rollouts, automated image updates, and robust observability with Prometheus/Grafana.',
        techStack: ['Kubernetes', 'EKS', 'Terraform', 'ArgoCD', 'Argo Rollouts', 'GitHub Actions', 'Prometheus', 'Grafana', 'Velero', 'Redis', 'PostgreSQL'],
        features: [
            'EKS-ready hardened manifests',
            'Terraform IaC scaffolding (VPC/EKS/ECR/IRSA)',
            'GitOps with ArgoCD (App-of-Apps pattern)',
            'Progressive Delivery (Canary) with Argo Rollouts',
            'Automated Image Updates',
            'Disaster Recovery with Velero',
            'Encrypted Secrets (Sealed Secrets)',
        ],
        achievements: [
            'Implemented full GitOps workflow',
            'Achieved zero-downtime canary deployments',
            'Automated infrastructure provisioning with Terraform',
        ],
        learningOutcomes: [
            'Mastered EKS cluster management',
            'Deep dive into Argo ecosystem (CD, Rollouts, Image Updater)',
            'Production-grade observability patterns',
        ],
        useCases: ['Enterprise Microservices Platform', 'SaaS Infrastructure'],
        githubUrl: 'https://github.com/Raj-glitch-max/FullStack-MicroServices',
        architecture: 'graph TD\n    User --> ALB["ALB Ingress"]\n    ALB --> FE["Frontend Service"]\n    FE --> BE["Backend Service"]\n    BE --> DB[("Postgres")]\n    BE --> Cache[("Redis")]\n    Git[("GitHub")] --> ArgoCD\n    ArgoCD --> K8s["EKS Cluster"]\n    Prom["Prometheus"] --> Graf["Grafana"]\n    Velero --> S3[("S3 Backups")]',
    },
    {
        name: 'terraform-ATLAS',
        shortDescription: 'Modular, production-ready AWS infrastructure library.',
        fullDescription: 'Terraform Atlas is a comprehensive library of reusable Terraform modules designed for deploying secure, scalable, and production-ready AWS infrastructure. It follows a modular architecture with zero-trust security defaults, covering VPC, Compute (ASG), Databases (RDS), and Monitoring.',
        techStack: ['Terraform', 'AWS', 'Auto Scaling', 'RDS', 'ALB', 'IAM', 'CloudWatch', 'S3', 'VPC'],
        features: [
            'Modular VPC with multi-AZ public/private subnets',
            'Zero-trust security groups architecture',
            'Auto Scaling Groups with launch templates',
            'RDS PostgreSQL with encryption and Multi-AZ',
            'ALB with HTTPS and path-based routing',
            'Integrated CloudWatch monitoring and alarms',
        ],
        achievements: [
            'Standardized infrastructure deployment patterns',
            'Enforced least-privilege IAM policies',
            'Enabled rapid environment spinning (Dev/Stage/Prod)',
        ],
        learningOutcomes: [
            'Advanced Terraform module design',
            'AWS networking and security best practices',
            'Infrastructure lifecycle management',
        ],
        useCases: ['Bootstrapping AWS Environments', 'Infrastructure Standardization'],
        githubUrl: 'https://github.com/Raj-glitch-max/terraform-ATLAS',
        architecture: 'graph TD\n    Internet --> ALB["ALB (Public)"]\n    ALB --> ASG["Auto Scaling Group (Private)"]\n    ASG --> RDS[("RDS Database (Private)")]\n    CloudWatch --> SNS["SNS Alerts"]\n    S3[("S3 State")] --> Terraform',
    },
    {
        name: 'AuroraLink-Forge',
        shortDescription: 'Serverless URL shortener with analytics and expiration.',
        fullDescription: 'AuroraLink-Forge is a high-performance, serverless URL shortening service built on AWS. It leverages AWS SAM, Lambda, and DynamoDB to provide low-latency link resolution, click tracking, and automated link expiration. The architecture is fully event-driven and scales automatically.',
        techStack: ['AWS SAM', 'Lambda', 'DynamoDB', 'API Gateway', 'EventBridge', 'Python', 'CloudWatch'],
        features: [
            'Serverless architecture (Zero server management)',
            'High-performance DynamoDB single-table design',
            'Automated link expiration (TTL + EventBridge)',
            'Click analytics and tracking',
            'Infrastructure as Code with AWS SAM',
            'Structured JSON logging',
        ],
        achievements: [
            'Built a fully serverless application',
            'Implemented DynamoDB advanced patterns',
            'Automated cleanup of expired resources',
        ],
        learningOutcomes: [
            'Serverless application design',
            'DynamoDB modeling and TTL',
            'Event-driven architecture patterns',
        ],
        useCases: ['Marketing Campaigns', 'Link Management'],
        githubUrl: 'https://github.com/Raj-glitch-max/AuroraLink-Forge',
        architecture: 'graph TD\n    User --> API["API Gateway"]\n    API --> Create["Lambda: Create"]\n    API --> Resolve["Lambda: Resolve"]\n    Create --> DDB[("DynamoDB")]\n    Resolve --> DDB\n    EventBridge --> Cleanup["Lambda: Cleanup"]\n    Cleanup --> DDB',
    },
    {
        name: 'CloudDrift Guardian',
        shortDescription: 'Multi-cloud FinOps & Compliance platform.',
        fullDescription: 'CloudDrift Guardian is an enterprise-grade platform for detecting infrastructure drift, optimizing costs, and enforcing policies across AWS, GCP, and Azure. It compares live infrastructure against IaC state, analyzes spending patterns, and ensures compliance using Open Policy Agent (OPA).',
        techStack: ['Python', 'FastAPI', 'React', 'Terraform', 'OPA', 'ClickHouse', 'PostgreSQL', 'RabbitMQ', 'Redis'],
        features: [
            'Multi-cloud Drift Detection (AWS, GCP, Azure)',
            'Cost Optimization & Right-sizing engine',
            'Policy Enforcement via OPA (Open Policy Agent)',
            'Real-time Dashboard with WebSocket updates',
            'Time-series cost analysis with ClickHouse',
            'Automated Remediation workflows',
        ],
        achievements: [
            'Unified view of multi-cloud posture',
            'Real-time drift alerts',
            'Scalable microservices architecture',
        ],
        learningOutcomes: [
            'FinOps and Cost Management strategies',
            'Policy-as-Code implementation',
            'Building data-intensive applications',
        ],
        useCases: ['Cloud Cost Management', 'Security Compliance', 'Infrastructure Auditing'],
        githubUrl: 'https://github.com/Raj-glitch-max/CloudDrift-Guardian', // Assuming repo name based on pattern
        architecture: 'graph TD\n    Clouds["AWS/GCP/Azure"] --> Scanner["Drift Scanner"]\n    Scanner --> MQ["RabbitMQ"]\n    MQ --> Engine["Drift/Cost Engine"]\n    Engine --> OPA["Policy Engine"]\n    Engine --> CH[("ClickHouse")]\n    Engine --> PG[("Postgres")]\n    PG --> API["FastAPI"]\n    API --> UI["React Dashboard"]',
    },
];
